/** **************************************************************************
 * THIS FILE IS AUTO-GENERATED BY plop
 * Do not manually change
 ** ************************************************************************ */

const debug = require("debug")("fsm:controller");


import update from "immutability-helper";
import * as StateMachine from "@taoqf/javascript-state-machine";
import * as _ from "lodash";
import { Action } from "redux";
import { all, call, put, spawn, fork, select, take, takeEvery, takeLatest } from "redux-saga/effects";
import { END, eventChannel } from "redux-saga";
import { FsmState, initialFsmState } from "./index";
import { PayloadAction } from "@src/store";

export interface StateMachineState {
    fsm: StateMachine
}

export let initialStateMachineState: StateMachineState = {
    fsm: null
};

export interface IDispatchFunction {
    onBeforeTransition: Function;
    onTransition: Function;
    onLeaveState: Function;
    onEnterState: Function;
}

export let fsmDispatchFunctions: IDispatchFunction = {
    onBeforeTransition: null,
    onTransition: null,
    onLeaveState: null,
    onEnterState: null
};

export const TRANSITION_ERROR = 'TRANSITION_ERROR';
export const transitionError = (action: string): PayloadAction<{ action: string }> => ({
    payload: {action},
    type: TRANSITION_ERROR,
});

//////////////////////////////////// Transitions ////////////////////////////////////

{{#each transitions}}
export const {{this.transNameCaps}}: string = '{{this.transNameCaps}}';
export const {{this.beforeTransNameCaps}}: string = '{{this.beforeTransNameCaps}}';
export const {{this.canTransNameCaps}}: string = '{{this.canTransNameCaps}}';
export const {{this.errorTransNameCaps}}: string = '{{this.errorTransNameCaps}}';
export const {{this.transName}} = () => ({ type: {{this.transNameCaps}} });
export const {{this.beforeTransName}} = () => ({ type: {{this.beforeTransNameCaps}} });
export const {{this.canTransName}} = () => ({ type: {{this.canTransNameCaps}} });
export const {{this.errorTransName}} = () => ({ type: {{this.errorTransNameCaps}} });

{{/each}}

//////////////////////////////////// States ////////////////////////////////////

{{#each states}}
export const {{this.stateNameCaps}}: string = '{{this.stateNameCaps}}';
export const {{this.beforeStateNameCaps}}: string = '{{this.beforeStateNameCaps}}';
export const {{this.leaveStateNameCaps}}: string = '{{this.leaveStateNameCaps}}';
export const {{this.stateName}} = () => ({ type: {{this.stateNameCaps}} });
export const {{this.beforeStateName}} = () => ({ type: {{this.beforeStateNameCaps}} });
export const {{this.leaveStateName}} = () => ({ type: {{this.leaveStateNameCaps}} });

{{/each}}

//////////////////////////////////// FSM ////////////////////////////////////

function getStateNames(o) {
    let data: any = {};
    data.stateName = o + "State";
    data.beforeStateName = "onBefore" + _.upperFirst(data.stateName)
    data.leaveStateName = "onLeave" + _.upperFirst(data.stateName);
    data.stateNameCaps = _.snakeCase(data.stateName).toUpperCase();
    data.beforeStateNameCaps = _.snakeCase(data.beforeStateName).toUpperCase();
    data.leaveStateNameCaps = _.snakeCase(data.leaveStateName).toUpperCase();
    return data;
}

function getTransNames(o) {
    let data: any = {};
    data.transName = o + "Trans";
    data.beforeTransName = "onBefore" + _.upperFirst(data.transName);
    data.canTransName = "can" + _.upperFirst(data.transName);
    data.errorTransName = "error" + _.upperFirst(data.transName);
    data.transNameCaps = _.snakeCase(data.transName).toUpperCase();
    data.beforeTransNameCaps = _.snakeCase(data.beforeTransName).toUpperCase();
    data.canTransNameCaps = _.snakeCase(data.canTransName).toUpperCase();
    return data;
}

export const fsmOptions: Partial<StateMachine.Options> = {
    init: {{states.0.stateNameCaps}},
    transitions: [{{#each transitions_list}}
        { {{name}}{{from}}{{to}} },{{/each}}
    ],

    methods: {
        onBeforeTransition: function(lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onBeforeTransition) return true;
            let event = "onBeforeTransition", 
                type = trans.beforeTransNameCaps;
            return fsmDispatchFunctions.onBeforeTransition({ event: event, type: type });
        },

        onTransition: function(lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onTransition) return true;
            let event = "onTransition", 
                type = trans.transNameCaps;
            return fsmDispatchFunctions.onTransition({ event: event, type: type });
        },

        onLeaveState: function(lifecycle) {
            let from_state = getStateNames(lifecycle.from);
            if (!fsmDispatchFunctions.onLeaveState) return true;
            let event = "onLeaveState", 
                type = from_state.leaveStateNameCaps;
            return fsmDispatchFunctions.onLeaveState({ event: event, type: type });
        },

        onEnterState: function(lifecycle) {
            let to_state = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onEnterState) return true;
            let event = "onEnterState", 
                type = to_state.stateNameCaps;
            return fsmDispatchFunctions.onEnterState({ event: event, type: type });
        }
    }
};

//////////////////////////////////// Sagas ////////////////////////////////////

export let fsmTransitionSagas: Function[] = [];

/* //////////////////////////////////// FSM Saga Generator //////////////////////////////////// */

export function connectFsm(fdf) {
    return eventChannel(emit => {
        const onBeforeTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onLeaveState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onEnterState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };

        fdf.onBeforeTransition = onBeforeTransition;
        fdf.onTransition = onTransition;
        fdf.onLeaveState = onLeaveState;
        fdf.onEnterState = onEnterState;

        return () => {
            debug("Unsubscribe connectFsm");
            fdf.onBeforeTransition = null;
            fdf.onTransition = null;
            fdf.onLeaveState = null;
            fdf.onEnterState = null;
        };
    });
}

export function* fsmDispatch(details) {
    yield put({ type: details.type });
}

export function* stateMachineDriver() {
    try {
        yield put(fsmCreate());
        const myClient = yield call(connectFsm, fsmDispatchFunctions);
        while (true) {
            let action = yield take(myClient);
            let state = yield select();
            if (action.event === "onEnterState" || action.event === "onTransition") {
                action.resolve();
                yield fork(fsmDispatch, action);
            } else {
                try {
                    yield put({ type: action.type });
                    action.resolve();
                } catch (err) {
                    debug(err);
                    action.reject();
                }
            }
        }
    } catch (err) {
        debug(err);
        //debugger;
    }
}

{{#each transitions}}
export function* {{transName}}Saga( ) {
    const fsm: StateMachine = yield select(getFsmStateMachine);
    if (fsm.can({{{transNameCaps}}})) {
        debug('Dispatching {{transName}} in FSM');
        fsm.{{transName}}();
    } else {
        debug(`Cannot transition from ${fsm.state} with {{transName}}`);
        yield put({{errorTransName}}());
        yield put(transitionError({{transNameCaps}}));
    }
}

{{/each}}
fsmTransitionSagas.push(stateMachineDriver);
fsmTransitionSagas.push(function* () {
{{#each transitions}}
    yield takeLatest({{{transNameCaps}}}, {{transName}}Saga);
{{/each}}
});

// ****************************** [ FSM Creation ] ****************************** //
export const FSM_CREATE: string = "FSM_CREATE";
export let fsmCreate = () => ({ type: FSM_CREATE });

export let fsmCreateReducer = (state = initialStateMachineState, { type }: Action): StateMachineState => {
    debug(type);
    switch (type) {
        case FSM_CREATE: {
            let fsm: StateMachine = new StateMachine(fsmOptions);
            debug("Creating FSM");
            let t = update(state, { fsm: { $set: fsm } });
            return t;
        }
        default:
            return state;
    }
}

export function getFsmState(state: any): FsmState {
    return state.app.fsm;
}

export function getFsmStateMachine(state: any): StateMachine {
    let fsmState: any = getFsmState(state);
    return fsmState.fsm.fsm;
}