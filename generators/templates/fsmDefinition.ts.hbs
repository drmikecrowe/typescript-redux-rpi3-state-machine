// * ************************************************************************
// * THIS FILE IS AUTO-GENERATED BY plop
// * Do not manually change
// * ************************************************************************

import { getFsmStateMachine } from "./index";
import * as StateMachine from "@taoqf/javascript-state-machine";
import update from "immutability-helper";
import * as _ from "lodash";
import { Action } from "redux";
import { eventChannel } from "redux-saga";
import { all, call, delay, fork, put, race, select, take, takeLatest } from "redux-saga/effects";

import debug from "debug";
const silly: debug.Debugger = debug("silly:fsm:fsmDefinitions");
const dbg: debug.Debugger = debug("fsm:fsm:fsmDefinitions");

export interface IStateMachineState {
    fsm: StateMachine;
}

export let initialStateMachineState: IStateMachineState = {
    fsm: null,
};

export interface IDispatchFunction {
    onBeforeTransition: (params:any) => boolean | Promise<boolean>;
    onEnterState: (params:any) => boolean | Promise<boolean>;
    onLeaveState: (params:any) => boolean | Promise<boolean>;
    onTransition: (params:any) => boolean | Promise<boolean>;
}

export let fsmDispatchFunctions: IDispatchFunction = {
    onBeforeTransition: null,
    onEnterState: null,
    onLeaveState: null,
    onTransition: null,
};

export const CANCEL_TRANSITION: string = "CANCEL_TRANSITION";
export let cancelTransition = () => ({ type: CANCEL_TRANSITION });

export const TRANSITION_ERROR = "TRANSITION_ERROR";
export const transitionError = (action: string) => ({
    payload: {action},
    type: TRANSITION_ERROR,
});

//////////////////////////////////// Transitions ////////////////////////////////////

{{#each transitions}}
export const {{this.canTransNameCaps}}: string = '{{this.canTransNameCaps}}';
export const {{this.fireTransNameCaps}}: string = '{{this.fireTransNameCaps}}';
export const {{this.beforeTransNameCaps}}: string = '{{this.beforeTransNameCaps}}';
export const {{this.errorTransNameCaps}}: string = '{{this.errorTransNameCaps}}';
export const {{this.fireTransName}} = () => ({ type: {{this.fireTransNameCaps}} });
export const {{this.beforeTransName}} = () => ({ type: {{this.beforeTransNameCaps}} });
export const {{this.errorTransName}} = () => ({ type: {{this.errorTransNameCaps}} });

{{/each}}

//////////////////////////////////// States ////////////////////////////////////

{{#each states}}
export const {{this.stateNameCaps}}: string = '{{this.stateNameCaps}}';
export const {{this.beforeStateNameCaps}}: string = '{{this.beforeStateNameCaps}}';
export const {{this.leaveStateNameCaps}}: string = '{{this.leaveStateNameCaps}}';
export const {{this.stateName}} = () => ({ type: {{this.stateNameCaps}} });
export const {{this.beforeStateName}} = () => ({ type: {{this.beforeStateNameCaps}} });
export const {{this.leaveStateName}} = () => ({ type: {{this.leaveStateNameCaps}} });

{{/each}}

//////////////////////////////////// FSM ////////////////////////////////////

function getStateNames(o) {
    const data: any = {};
    o = _.camelCase(o.replace("CAN_", ""));
    data.stateName = o;
    data.stateNameCaps = _.snakeCase(data.stateName).toUpperCase();
    data.beforeStateName = "onBefore" + _.upperFirst(data.stateName);
    data.beforeStateNameCaps = _.snakeCase(data.beforeStateName).toUpperCase();
    data.leaveStateName = "onLeave" + _.upperFirst(data.stateName);
    data.leaveStateNameCaps = _.snakeCase(data.leaveStateName).toUpperCase();
    return data;
}

function getTransNames(o) {
    const data: any = {};
    o = _.camelCase(o.replace("CAN_", ""));
    data.canTransName = "can" + _.upperFirst(o.replace("CAN_", ""));
    data.canTransNameCaps = _.snakeCase(data.canTransName).toUpperCase();
    data.fireTransName = "fire" + _.upperFirst(o.replace("CAN_", ""));
    data.fireTransNameCaps = _.snakeCase(data.fireTransName).toUpperCase();
    data.beforeTransName = "onBefore" + _.upperFirst(data.fireTransName);
    data.beforeTransNameCaps = _.snakeCase(data.beforeTransName).toUpperCase();
    data.errorTransName = "error" + _.upperFirst(data.fireTransName);
    data.errorTransNameCaps = _.snakeCase(data.errorTransName).toUpperCase();
    return data;
}

export const fsmOptions: Partial<StateMachine.Options> = {
    init: {{defaultState}},
    transitions: [{{#each transitions_list}}
        { {{name}}{{from}}{{to}} },{{/each}}
    ],

    methods: {
        onBeforeTransition(lifecycle) {
            const trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onBeforeTransition) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            f[`${lifecycle.to}_CANCEL`] = false;
            f[`CURRENT_TRANSITION`] = lifecycle.to;
            return fsmDispatchFunctions.onBeforeTransition({ event: "onBeforeTransition", type: trans.beforeTransNameCaps });
        },

        onTransition: function(lifecycle) {
            const trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onTransition) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            if (f[`${lifecycle.to}_CANCEL`]) {
                dbg(`Canceling transition to ${lifecycle.to} (onTransition)`);
                return false;
            }
            return fsmDispatchFunctions.onTransition({ event: "onTransition", type: trans.canTransNameCaps });
        },

        onLeaveState(lifecycle) {
            const stateFrom = getStateNames(lifecycle.from);
            const stateTo = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onLeaveState) {
                return true;
            }
            return Promise.all([
                fsmDispatchFunctions.onLeaveState({ event: "onLeaveState", type: stateFrom.leaveStateNameCaps }),
                fsmDispatchFunctions.onLeaveState({ event: "onBeforeEnterState", type: stateTo.beforeStateNameCaps }),
            ])
                .then(() => true);
        },

        onEnterState(lifecycle) {
            const state = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onEnterState) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            if (f[`${state.stateNameCaps}_CANCEL`]) {
                dbg(`Canceling transition to ${state.stateNameCaps} (onEnterState)`);
                return false;
            }
            return fsmDispatchFunctions.onEnterState({ event: "onEnterState", type: state.stateNameCaps });
        },
    },
};

//////////////////////////////////// Sagas ////////////////////////////////////

export let fsmTransitionSagas: Array<() => void> = [];

/* //////////////////////////////////// FSM Saga Generator //////////////////////////////////// */

export function connectFsm(fdf) {
    return eventChannel(emit => {
        const onBeforeTransition = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onTransition = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onLeaveState = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onEnterState = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };

        fdf.onBeforeTransition = onBeforeTransition;
        fdf.onTransition = onTransition;
        fdf.onLeaveState = onLeaveState;
        fdf.onEnterState = onEnterState;

        return () => {
            dbg("Unsubscribe connectFsm");
            fdf.onBeforeTransition = null;
            fdf.onTransition = null;
            fdf.onLeaveState = null;
            fdf.onEnterState = null;
        };
    });
}

export function* fsmDispatch(details) {
    yield put({ type: details.type });
}

export function* stateMachineDriver() {
    try {
        yield put(fsmCreate());
        const myClient = yield call(connectFsm, fsmDispatchFunctions);
        while (true) {
            const action = yield take(myClient);
            if (action.event === "onEnterState" || action.event === "onTransition") {
                action.resolve();
                yield fork(fsmDispatch, action);
            } else {
                try {
                    yield put({ type: action.type });
                    action.resolve();
                } catch (err) {
                    dbg(err);
                    action.reject();
                }
            }
        }
    } catch (err) {
        dbg(err);
        // debugger;
    }
}

{{#each transitions}}
export function* {{fireTransName}}Saga() {
    yield takeLatest({{{fireTransNameCaps}}}, function* () {
        const fsm: StateMachine = yield select(getFsmStateMachine);
        if (fsm.can({{{canTransNameCaps}}})) {
            dbg('Dispatching {{canTransName}} in FSM');
            fsm.{{canTransName}}();
            const { wait, undo } = yield race({
                undo: take(CANCEL_TRANSITION),
                wait: delay(1),
            });
            const f: any = fsm._fsm;
            if (!!undo) {
                f[`${f[`CURRENT_TRANSITION`]}_CANCEL`] = true;
                dbg(`Cancelling {{stateNameCaps}}`);
            }
        } else {
            dbg(`Cannot transition from ${fsm.state} with {{fireTransName}}`);
            yield put({{errorTransName}}());
            yield put(transitionError({{fireTransNameCaps}}));
        }
    });
}

{{/each}}

export function* fsmTransitionSaga() {
    yield all([
        yield fork(stateMachineDriver),
{{#each transitions}}
        yield fork({{fireTransName}}Saga),
{{/each}}
    ]);
}
fsmTransitionSagas.push(fsmTransitionSaga);

// ****************************** [ FSM Creation ] ****************************** //
export const FSM_CREATE: string = "FSM_CREATE";
export const fsmCreate = () => ({ type: FSM_CREATE });

export const fsmCreateReducer = (state = initialStateMachineState, { type }: Action): IStateMachineState => {
    silly(`(silly): ${type}`);
    switch (type) {
        case FSM_CREATE: {
            const fsm: StateMachine = new StateMachine(fsmOptions);
            dbg("Creating FSM");
            return update(state, { fsm: { $set: fsm } });
        }
        default:
            return state;
    }
};
