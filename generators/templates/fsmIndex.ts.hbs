// * ************************************************************************
// * THIS FILE IS AUTO-GENERATED BY plop
// * Do not manually change
// * ************************************************************************

import * as _ from 'lodash';

import { combineReducers } from "redux";
import * as StateMachine from "@taoqf/javascript-state-machine";
import { fsmCreateReducer, fsmOptions, fsmTransitionSagas, IStateMachineState, initialStateMachineState } from "./fsmDefinitions";

{{#each states}}
import { fsm{{stateName}}Reducer, I{{stateName}}, initial{{stateName}}, {{stateName}}Sagas } from "./states/{{stateName}}";
{{/each}}

export * from "./fsmDefinitions";

export let fsmSagas: Array<() => void> = _.concat(fsmTransitionSagas, 
{{#each states}}    {{stateName}}Sagas{{#if @last}}{{else}},{{/if}}
{{/each}}
);

export interface IFsmState {
{{#each states}}    {{stateName}}: I{{stateName}}
{{/each}}
    fsm: IStateMachineState,
}

export let initialFsmState: IFsmState = {
{{#each states}}    {{stateName}}: initial{{stateName}},
{{/each}}
    fsm: initialStateMachineState,
};

export function getFsmState(state: any): IFsmState {
    if (_.has(state, 'fsm.fsm')) {     // Jest testing returns IFsmState directly
        return state.fsm;
    }
    return state;
}

export function getFsmStateMachine(state: any): StateMachine {
    const fsmState: any = getFsmState(state);
    return fsmState.fsm;
}

function attachNestedReducers(original, reducers) {
    const nestedReducerKeys = Object.keys(reducers);
    return function combination(state, action) {
        const nextState = original(state, action);
        let hasChanged = false;
        const nestedState = {};
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < nestedReducerKeys.length; i++) {
            const key = nestedReducerKeys[i];
            const reducer = reducers[key];
            const previousStateForKey = nextState[key];
            const nextStateForKey = reducer(previousStateForKey, action);
            nestedState[key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        // tslint:disable-next-line:prefer-object-spread
        return hasChanged ? Object.assign({}, nextState, nestedState) : nextState;
    };
}
export const fsmStateReducer = attachNestedReducers(fsmCreateReducer, {
{{#each states}}    {{stateName}}: fsm{{stateName}}Reducer,
{{/each}}
});
