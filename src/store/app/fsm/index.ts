// * ************************************************************************
// * THIS FILE IS AUTO-GENERATED BY plop
// * Do not manually change
// * ************************************************************************

import * as _ from 'lodash';

import { combineReducers } from "redux";
import * as StateMachine from "@taoqf/javascript-state-machine";
import { fsmCreateReducer, fsmOptions, fsmTransitionSagas, IStateMachineState, initialStateMachineState } from "./fsmDefinitions";

import { fsmClosedStateReducer, IClosedState, initialClosedState, ClosedStateSagas } from "./states/ClosedState";
import { fsmOpenedStateReducer, IOpenedState, initialOpenedState, OpenedStateSagas } from "./states/OpenedState";

export * from "./fsmDefinitions";

export let fsmSagas: Array<() => void> = _.concat(fsmTransitionSagas, 
    ClosedStateSagas,
    OpenedStateSagas
);

export interface IFsmState {
    ClosedState: IClosedState
    OpenedState: IOpenedState
    fsm: IStateMachineState,
}

export let initialFsmState: IFsmState = {
    ClosedState: initialClosedState,
    OpenedState: initialOpenedState,
    fsm: initialStateMachineState,
};

export function getFsmState(state: any): IFsmState {
    if (_.has(state, 'fsm.fsm')) {     // Jest testing returns IFsmState directly
        return state.fsm;
    }
    return state;
}

export function getFsmStateMachine(state: any): StateMachine {
    const fsmState: any = getFsmState(state);
    return fsmState.fsm;
}

function attachNestedReducers(original, reducers) {
    const nestedReducerKeys = Object.keys(reducers);
    return function combination(state, action) {
        const nextState = original(state, action);
        let hasChanged = false;
        const nestedState = {};
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < nestedReducerKeys.length; i++) {
            const key = nestedReducerKeys[i];
            const reducer = reducers[key];
            const previousStateForKey = nextState[key];
            const nextStateForKey = reducer(previousStateForKey, action);
            nestedState[key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        // tslint:disable-next-line:prefer-object-spread
        return hasChanged ? Object.assign({}, nextState, nestedState) : nextState;
    };
}
export const fsmStateReducer = attachNestedReducers(fsmCreateReducer, {
    ClosedState: fsmClosedStateReducer,
    OpenedState: fsmOpenedStateReducer,
});
