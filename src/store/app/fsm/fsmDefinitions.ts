/** **************************************************************************
 * THIS FILE IS AUTO-GENERATED BY plop
 * Do not manually change
 ** ************************************************************************ */

const debug = require("debug")("fsm:controller");


import update from "immutability-helper";
import * as StateMachine from "@taoqf/javascript-state-machine";
import * as _ from "lodash";
import { Action } from "redux";
import { all, call, put, spawn, fork, select, take, takeEvery, takeLatest } from "redux-saga/effects";
import { delay, END, eventChannel } from "redux-saga";
import { FsmState, initialFsmState } from "./index";
import { PayloadAction } from "@src/store";

export interface StateMachineState {
    fsm: StateMachine
}

export let initialStateMachineState: StateMachineState = {
    fsm: null
};

export interface IDispatchFunction {
    onBeforeTransition: Function;
    onTransition: Function;
    onLeaveState: Function;
    onEnterState: Function;
}

export let fsmDispatchFunctions: IDispatchFunction = {
    onBeforeTransition: null,
    onTransition: null,
    onLeaveState: null,
    onEnterState: null
};

export const TRANSITION_ERROR = 'TRANSITION_ERROR';
export const transitionError = (action: string): PayloadAction<{ action: string }> => ({
    payload: {action},
    type: TRANSITION_ERROR,
});

//////////////////////////////////// Transitions ////////////////////////////////////

export const FIRE_DO_OPEN: string = 'FIRE_DO_OPEN';
export const ON_BEFORE_FIRE_DO_OPEN: string = 'ON_BEFORE_FIRE_DO_OPEN';
export const CAN_FIRE_DO_OPEN: string = 'CAN_FIRE_DO_OPEN';
export const ERROR_FIRE_DO_OPEN: string = 'ERROR_FIRE_DO_OPEN';
export const fireDoOpen = () => ({ type: FIRE_DO_OPEN });
export const onBeforeFireDoOpen = () => ({ type: ON_BEFORE_FIRE_DO_OPEN });
export const canFireDoOpen = () => ({ type: CAN_FIRE_DO_OPEN });
export const errorFireDoOpen = () => ({ type: ERROR_FIRE_DO_OPEN });

export const FIRE_DO_CLOSE: string = 'FIRE_DO_CLOSE';
export const ON_BEFORE_FIRE_DO_CLOSE: string = 'ON_BEFORE_FIRE_DO_CLOSE';
export const CAN_FIRE_DO_CLOSE: string = 'CAN_FIRE_DO_CLOSE';
export const ERROR_FIRE_DO_CLOSE: string = 'ERROR_FIRE_DO_CLOSE';
export const fireDoClose = () => ({ type: FIRE_DO_CLOSE });
export const onBeforeFireDoClose = () => ({ type: ON_BEFORE_FIRE_DO_CLOSE });
export const canFireDoClose = () => ({ type: CAN_FIRE_DO_CLOSE });
export const errorFireDoClose = () => ({ type: ERROR_FIRE_DO_CLOSE });


//////////////////////////////////// States ////////////////////////////////////

export const CLOSED_STATE: string = 'CLOSED_STATE';
export const ON_BEFORE_CLOSED_STATE: string = 'ON_BEFORE_CLOSED_STATE';
export const ON_LEAVE_CLOSED_STATE: string = 'ON_LEAVE_CLOSED_STATE';
export const ClosedState = () => ({ type: CLOSED_STATE });
export const onBeforeClosedState = () => ({ type: ON_BEFORE_CLOSED_STATE });
export const onLeaveClosedState = () => ({ type: ON_LEAVE_CLOSED_STATE });

export const OPENED_STATE: string = 'OPENED_STATE';
export const ON_BEFORE_OPENED_STATE: string = 'ON_BEFORE_OPENED_STATE';
export const ON_LEAVE_OPENED_STATE: string = 'ON_LEAVE_OPENED_STATE';
export const OpenedState = () => ({ type: OPENED_STATE });
export const onBeforeOpenedState = () => ({ type: ON_BEFORE_OPENED_STATE });
export const onLeaveOpenedState = () => ({ type: ON_LEAVE_OPENED_STATE });


//////////////////////////////////// FSM ////////////////////////////////////

function getStateNames(o) {
    let data: any = {};
    data.stateName = o + "State";
    data.beforeStateName = "onBefore" + _.upperFirst(data.stateName)
    data.leaveStateName = "onLeave" + _.upperFirst(data.stateName);
    data.stateNameCaps = _.snakeCase(data.stateName).toUpperCase();
    data.beforeStateNameCaps = _.snakeCase(data.beforeStateName).toUpperCase();
    data.leaveStateNameCaps = _.snakeCase(data.leaveStateName).toUpperCase();
    return data;
}

function getTransNames(o) {
    let data: any = {};
    data.transName = o + "Trans";
    data.beforeTransName = "onBefore" + _.upperFirst(data.transName);
    data.canTransName = "can" + _.upperFirst(data.transName);
    data.errorTransName = "error" + _.upperFirst(data.transName);
    data.transNameCaps = _.snakeCase(data.transName).toUpperCase();
    data.beforeTransNameCaps = _.snakeCase(data.beforeTransName).toUpperCase();
    data.canTransNameCaps = _.snakeCase(data.canTransName).toUpperCase();
    return data;
}

export const fsmOptions: StateMachine.Options = {
    init: CLOSED_STATE,
    transitions: [
        { name: FIRE_DO_OPEN,                               from: CLOSED_STATE,                     to: OPENED_STATE,                        },
        { name: FIRE_DO_CLOSE,                              from: OPENED_STATE,                     to: CLOSED_STATE,                        },
    ],

    methods: {
        onBeforeTransition: function(lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onBeforeTransition) return true;
            let event = "onBeforeTransition", 
                type = trans.beforeTransNameCaps;
            return fsmDispatchFunctions.onBeforeTransition({ event: event, type: type });
        },

        onTransition: function(lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onTransition) return true;
            let event = "onTransition", 
                type = trans.transNameCaps;
            return fsmDispatchFunctions.onTransition({ event: event, type: type });
        },

        onLeaveState: function(lifecycle) {
            let from_state = getStateNames(lifecycle.from);
            if (!fsmDispatchFunctions.onLeaveState) return true;
            let event = "onLeaveState", 
                type = from_state.leaveStateNameCaps;
            return fsmDispatchFunctions.onLeaveState({ event: event, type: type });
        },

        onEnterState: function(lifecycle) {
            let to_state = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onEnterState) return true;
            let event = "onEnterState", 
                type = to_state.stateNameCaps;
            return fsmDispatchFunctions.onEnterState({ event: event, type: type });
        }
    }
};

//////////////////////////////////// Sagas ////////////////////////////////////

export let fsmTransitionSagas: Function[] = [];

/* //////////////////////////////////// FSM Saga Generator //////////////////////////////////// */

export function connectFsm(fdf) {
    return eventChannel(emit => {
        const onBeforeTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onLeaveState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onEnterState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };

        fdf.onBeforeTransition = onBeforeTransition;
        fdf.onTransition = onTransition;
        fdf.onLeaveState = onLeaveState;
        fdf.onEnterState = onEnterState;

        return () => {
            debug("Unsubscribe connectFsm");
            fdf.onBeforeTransition = null;
            fdf.onTransition = null;
            fdf.onLeaveState = null;
            fdf.onEnterState = null;
        };
    });
}

export function* fsmDispatch(details) {
    yield put({ type: details.type });
}

export function* stateMachineDriver() {
    try {
        yield put(fsmCreate());
        const myClient = yield call(connectFsm, fsmDispatchFunctions);
        while (true) {
            let action = yield take(myClient);
            let state = yield select();
            if (action.event === "onEnterState" || action.event === "onTransition") {
                action.resolve();
                yield fork(fsmDispatch, action);
            } else {
                try {
                    yield put({ type: action.type });
                    action.resolve();
                } catch (err) {
                    debug(err);
                    action.reject();
                }
            }
        }
    } catch (err) {
        debug(err);
        //debugger;
    }
}

export function* fireDoOpenSaga( ) {
    const fsm: StateMachine = yield select(getFsmStateMachine);
    if (fsm.can(FIRE_DO_OPEN)) {
        debug('Dispatching fireDoOpen in FSM');
        fsm.fireDoOpen();
    } else {
        debug(`Cannot transition from ${fsm.state} with fireDoOpen`);
        yield put(errorFireDoOpen());
        yield put(transitionError(FIRE_DO_OPEN));
    }
}

export function* fireDoCloseSaga( ) {
    const fsm: StateMachine = yield select(getFsmStateMachine);
    if (fsm.can(FIRE_DO_CLOSE)) {
        debug('Dispatching fireDoClose in FSM');
        fsm.fireDoClose();
    } else {
        debug(`Cannot transition from ${fsm.state} with fireDoClose`);
        yield put(errorFireDoClose());
        yield put(transitionError(FIRE_DO_CLOSE));
    }
}

fsmTransitionSagas.push(stateMachineDriver);
fsmTransitionSagas.push(function* () {
    yield takeLatest(FIRE_DO_OPEN, fireDoOpenSaga);
    yield takeLatest(FIRE_DO_CLOSE, fireDoCloseSaga);
});

// ****************************** [ FSM Creation ] ****************************** //
export const FSM_CREATE: string = "FSM_CREATE";
export let fsmCreate = () => ({ type: FSM_CREATE });

export let fsmCreateReducer = (state = initialStateMachineState, { type }: Action): StateMachineState => {
    debug(type);
    switch (type) {
        case FSM_CREATE: {
            let fsm: StateMachine = new StateMachine(fsmOptions);
            debug("Creating FSM");
            let t = update(state, { fsm: { $set: fsm } });
            return t;
        }
        default:
            return state;
    }
}

export function getFsmState(state: any): FsmState {
    return state.app.fsm;
}

export function getFsmStateMachine(state: any): StateMachine {
    let fsmState: any = getFsmState(state);
    return fsmState.fsm.fsm;
}