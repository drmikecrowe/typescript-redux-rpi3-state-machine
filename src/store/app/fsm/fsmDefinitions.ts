// * ************************************************************************
// * THIS FILE IS AUTO-GENERATED BY plop
// * Do not manually change
// * ************************************************************************

import { getFsmStateMachine } from "./index";
import * as StateMachine from "@taoqf/javascript-state-machine";
import update from "immutability-helper";
import * as _ from "lodash";
import { Action } from "redux";
import { eventChannel } from "redux-saga";
import { all, call, delay, fork, put, race, select, take, takeLatest } from "redux-saga/effects";

import debug from "debug";
const silly: debug.Debugger = debug("silly:fsm:fsmDefinitions");
const dbg: debug.Debugger = debug("fsm:fsm:fsmDefinitions");

export interface IStateMachineState {
    fsm: StateMachine;
}

export let initialStateMachineState: IStateMachineState = {
    fsm: null,
};

export interface IDispatchFunction {
    onBeforeTransition: (params:any) => boolean | Promise<boolean>;
    onEnterState: (params:any) => boolean | Promise<boolean>;
    onLeaveState: (params:any) => boolean | Promise<boolean>;
    onTransition: (params:any) => boolean | Promise<boolean>;
}

export let fsmDispatchFunctions: IDispatchFunction = {
    onBeforeTransition: null,
    onEnterState: null,
    onLeaveState: null,
    onTransition: null,
};

export const CANCEL_TRANSITION: string = "CANCEL_TRANSITION";
export let cancelTransition = () => ({ type: CANCEL_TRANSITION });

export const TRANSITION_ERROR = "TRANSITION_ERROR";
export const transitionError = (action: string) => ({
    payload: {action},
    type: TRANSITION_ERROR,
});

//////////////////////////////////// Transitions ////////////////////////////////////

export const CAN_DO_OPEN: string = 'CAN_DO_OPEN';
export const FIRE_DO_OPEN: string = 'FIRE_DO_OPEN';
export const ON_BEFORE_FIRE_DO_OPEN: string = 'ON_BEFORE_FIRE_DO_OPEN';
export const ERROR_FIRE_DO_OPEN: string = 'ERROR_FIRE_DO_OPEN';
export const fireDoOpen = () => ({ type: FIRE_DO_OPEN });
export const onBeforeFireDoOpen = () => ({ type: ON_BEFORE_FIRE_DO_OPEN });
export const errorFireDoOpen = () => ({ type: ERROR_FIRE_DO_OPEN });

export const CAN_DO_CLOSE: string = 'CAN_DO_CLOSE';
export const FIRE_DO_CLOSE: string = 'FIRE_DO_CLOSE';
export const ON_BEFORE_FIRE_DO_CLOSE: string = 'ON_BEFORE_FIRE_DO_CLOSE';
export const ERROR_FIRE_DO_CLOSE: string = 'ERROR_FIRE_DO_CLOSE';
export const fireDoClose = () => ({ type: FIRE_DO_CLOSE });
export const onBeforeFireDoClose = () => ({ type: ON_BEFORE_FIRE_DO_CLOSE });
export const errorFireDoClose = () => ({ type: ERROR_FIRE_DO_CLOSE });


//////////////////////////////////// States ////////////////////////////////////

export const CLOSED_STATE: string = 'CLOSED_STATE';
export const ON_BEFORE_CLOSED_STATE: string = 'ON_BEFORE_CLOSED_STATE';
export const ON_LEAVE_CLOSED_STATE: string = 'ON_LEAVE_CLOSED_STATE';
export const ClosedState = () => ({ type: CLOSED_STATE });
export const onBeforeClosedState = () => ({ type: ON_BEFORE_CLOSED_STATE });
export const onLeaveClosedState = () => ({ type: ON_LEAVE_CLOSED_STATE });

export const OPENED_STATE: string = 'OPENED_STATE';
export const ON_BEFORE_OPENED_STATE: string = 'ON_BEFORE_OPENED_STATE';
export const ON_LEAVE_OPENED_STATE: string = 'ON_LEAVE_OPENED_STATE';
export const OpenedState = () => ({ type: OPENED_STATE });
export const onBeforeOpenedState = () => ({ type: ON_BEFORE_OPENED_STATE });
export const onLeaveOpenedState = () => ({ type: ON_LEAVE_OPENED_STATE });


//////////////////////////////////// FSM ////////////////////////////////////

function getStateNames(o) {
    const data: any = {};
    o = _.camelCase(o.replace("CAN_", ""));
    data.stateName = o;
    data.stateNameCaps = _.snakeCase(data.stateName).toUpperCase();
    data.beforeStateName = "onBefore" + _.upperFirst(data.stateName);
    data.beforeStateNameCaps = _.snakeCase(data.beforeStateName).toUpperCase();
    data.leaveStateName = "onLeave" + _.upperFirst(data.stateName);
    data.leaveStateNameCaps = _.snakeCase(data.leaveStateName).toUpperCase();
    return data;
}

function getTransNames(o) {
    const data: any = {};
    o = _.camelCase(o.replace("CAN_", ""));
    data.canTransName = "can" + _.upperFirst(o.replace("CAN_", ""));
    data.canTransNameCaps = _.snakeCase(data.canTransName).toUpperCase();
    data.fireTransName = "fire" + _.upperFirst(o.replace("CAN_", ""));
    data.fireTransNameCaps = _.snakeCase(data.fireTransName).toUpperCase();
    data.beforeTransName = "onBefore" + _.upperFirst(data.fireTransName);
    data.beforeTransNameCaps = _.snakeCase(data.beforeTransName).toUpperCase();
    data.errorTransName = "error" + _.upperFirst(data.fireTransName);
    data.errorTransNameCaps = _.snakeCase(data.errorTransName).toUpperCase();
    return data;
}

export const fsmOptions: Partial<StateMachine.Options> = {
    init: CLOSED_STATE,
    transitions: [
        { name: CAN_DO_OPEN,                                from: CLOSED_STATE,                     to: OPENED_STATE,                        },
        { name: CAN_DO_CLOSE,                               from: OPENED_STATE,                     to: CLOSED_STATE,                        },
    ],

    methods: {
        onBeforeTransition(lifecycle) {
            const trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onBeforeTransition) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            f[`${lifecycle.to}_CANCEL`] = false;
            f[`CURRENT_TRANSITION`] = lifecycle.to;
            return fsmDispatchFunctions.onBeforeTransition({ event: "onBeforeTransition", type: trans.beforeTransNameCaps });
        },

        onTransition: function(lifecycle) {
            const trans = getTransNames(lifecycle.transition);
            if (!fsmDispatchFunctions.onTransition) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            if (f[`${lifecycle.to}_CANCEL`]) {
                dbg(`Canceling transition to ${lifecycle.to} (onTransition)`);
                return false;
            }
            return fsmDispatchFunctions.onTransition({ event: "onTransition", type: trans.canTransNameCaps });
        },

        onLeaveState(lifecycle) {
            const stateFrom = getStateNames(lifecycle.from);
            const stateTo = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onLeaveState) {
                return true;
            }
            return Promise.all([
                fsmDispatchFunctions.onLeaveState({ event: "onLeaveState", type: stateFrom.leaveStateNameCaps }),
                fsmDispatchFunctions.onLeaveState({ event: "onBeforeEnterState", type: stateTo.beforeStateNameCaps }),
            ])
                .then(() => true);
        },

        onEnterState(lifecycle) {
            const state = getStateNames(lifecycle.to);
            if (!fsmDispatchFunctions.onEnterState) {
                return true;
            }
            let f: any = (lifecycle as any).fsm._fsm;
            if (f[`${state.stateNameCaps}_CANCEL`]) {
                dbg(`Canceling transition to ${state.stateNameCaps} (onEnterState)`);
                return false;
            }
            return fsmDispatchFunctions.onEnterState({ event: "onEnterState", type: state.stateNameCaps });
        },
    },
};

//////////////////////////////////// Sagas ////////////////////////////////////

export let fsmTransitionSagas: Array<() => void> = [];

/* //////////////////////////////////// FSM Saga Generator //////////////////////////////////// */

export function connectFsm(fdf) {
    return eventChannel(emit => {
        const onBeforeTransition = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onTransition = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onLeaveState = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };
        const onEnterState = state => {
            return new Promise((resolve, reject) => {
                dbg(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve, reject });
            });
        };

        fdf.onBeforeTransition = onBeforeTransition;
        fdf.onTransition = onTransition;
        fdf.onLeaveState = onLeaveState;
        fdf.onEnterState = onEnterState;

        return () => {
            dbg("Unsubscribe connectFsm");
            fdf.onBeforeTransition = null;
            fdf.onTransition = null;
            fdf.onLeaveState = null;
            fdf.onEnterState = null;
        };
    });
}

export function* fsmDispatch(details) {
    yield put({ type: details.type });
}

export function* stateMachineDriver() {
    try {
        yield put(fsmCreate());
        const myClient = yield call(connectFsm, fsmDispatchFunctions);
        while (true) {
            const action = yield take(myClient);
            if (action.event === "onEnterState" || action.event === "onTransition") {
                action.resolve();
                yield fork(fsmDispatch, action);
            } else {
                try {
                    yield put({ type: action.type });
                    action.resolve();
                } catch (err) {
                    dbg(err);
                    action.reject();
                }
            }
        }
    } catch (err) {
        dbg(err);
        // debugger;
    }
}

export function* fireDoOpenSaga() {
    yield takeLatest(FIRE_DO_OPEN, function* () {
        const fsm: StateMachine = yield select(getFsmStateMachine);
        if (fsm.can(CAN_DO_OPEN)) {
            dbg('Dispatching canDoOpen in FSM');
            fsm.canDoOpen();
            const { wait, undo } = yield race({
                undo: take(CANCEL_TRANSITION),
                wait: delay(1),
            });
            const f: any = fsm._fsm;
            if (!!undo) {
                f[`${f[`CURRENT_TRANSITION`]}_CANCEL`] = true;
                dbg(`Cancelling `);
            }
        } else {
            dbg(`Cannot transition from ${fsm.state} with fireDoOpen`);
            yield put(errorFireDoOpen());
            yield put(transitionError(FIRE_DO_OPEN));
        }
    });
}

export function* fireDoCloseSaga() {
    yield takeLatest(FIRE_DO_CLOSE, function* () {
        const fsm: StateMachine = yield select(getFsmStateMachine);
        if (fsm.can(CAN_DO_CLOSE)) {
            dbg('Dispatching canDoClose in FSM');
            fsm.canDoClose();
            const { wait, undo } = yield race({
                undo: take(CANCEL_TRANSITION),
                wait: delay(1),
            });
            const f: any = fsm._fsm;
            if (!!undo) {
                f[`${f[`CURRENT_TRANSITION`]}_CANCEL`] = true;
                dbg(`Cancelling `);
            }
        } else {
            dbg(`Cannot transition from ${fsm.state} with fireDoClose`);
            yield put(errorFireDoClose());
            yield put(transitionError(FIRE_DO_CLOSE));
        }
    });
}


export function* fsmTransitionSaga() {
    yield all([
        yield fork(stateMachineDriver),
        yield fork(fireDoOpenSaga),
        yield fork(fireDoCloseSaga),
    ]);
}
fsmTransitionSagas.push(fsmTransitionSaga);

// ****************************** [ FSM Creation ] ****************************** //
export const FSM_CREATE: string = "FSM_CREATE";
export const fsmCreate = () => ({ type: FSM_CREATE });

export const fsmCreateReducer = (state = initialStateMachineState, { type }: Action): IStateMachineState => {
    silly(`(silly): ${type}`);
    switch (type) {
        case FSM_CREATE: {
            const fsm: StateMachine = new StateMachine(fsmOptions);
            dbg("Creating FSM");
            return update(state, { fsm: { $set: fsm } });
        }
        default:
            return state;
    }
};
