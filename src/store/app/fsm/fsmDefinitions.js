"use strict";
/** **************************************************************************
 * THIS FILE IS AUTO-GENERATED BY plop
 * Do not manually change
 ** ************************************************************************ */
Object.defineProperty(exports, "__esModule", { value: true });
const debug = require("debug")("fsm:controller");
const immutability_helper_1 = require("immutability-helper");
const StateMachine = require("@taoqf/javascript-state-machine");
const _ = require("lodash");
const effects_1 = require("redux-saga/effects");
const redux_saga_1 = require("redux-saga");
exports.initialStateMachineState = {
    fsm: null
};
exports.fsmDispatchFunctions = {
    onBeforeTransition: null,
    onTransition: null,
    onLeaveState: null,
    onEnterState: null
};
//////////////////////////////////// Transitions ////////////////////////////////////
exports.FIRE_DO_OPEN = 'FIRE_DO_OPEN';
exports.ON_BEFORE_FIRE_DO_OPEN = 'ON_BEFORE_FIRE_DO_OPEN';
exports.CAN_FIRE_DO_OPEN = 'CAN_FIRE_DO_OPEN';
exports.fireDoOpen = () => ({ type: exports.FIRE_DO_OPEN });
exports.onBeforeFireDoOpen = () => ({ type: exports.ON_BEFORE_FIRE_DO_OPEN });
exports.canFireDoOpen = () => ({ type: exports.CAN_FIRE_DO_OPEN });
exports.FIRE_DO_CLOSE = 'FIRE_DO_CLOSE';
exports.ON_BEFORE_FIRE_DO_CLOSE = 'ON_BEFORE_FIRE_DO_CLOSE';
exports.CAN_FIRE_DO_CLOSE = 'CAN_FIRE_DO_CLOSE';
exports.fireDoClose = () => ({ type: exports.FIRE_DO_CLOSE });
exports.onBeforeFireDoClose = () => ({ type: exports.ON_BEFORE_FIRE_DO_CLOSE });
exports.canFireDoClose = () => ({ type: exports.CAN_FIRE_DO_CLOSE });
//////////////////////////////////// States ////////////////////////////////////
exports.CLOSED_STATE = 'CLOSED_STATE';
exports.ON_BEFORE_CLOSED_STATE = 'ON_BEFORE_CLOSED_STATE';
exports.ON_LEAVE_CLOSED_STATE = 'ON_LEAVE_CLOSED_STATE';
exports.ClosedState = () => ({ type: exports.CLOSED_STATE });
exports.onBeforeClosedState = () => ({ type: exports.ON_BEFORE_CLOSED_STATE });
exports.onLeaveClosedState = () => ({ type: exports.ON_LEAVE_CLOSED_STATE });
exports.OPENED_STATE = 'OPENED_STATE';
exports.ON_BEFORE_OPENED_STATE = 'ON_BEFORE_OPENED_STATE';
exports.ON_LEAVE_OPENED_STATE = 'ON_LEAVE_OPENED_STATE';
exports.OpenedState = () => ({ type: exports.OPENED_STATE });
exports.onBeforeOpenedState = () => ({ type: exports.ON_BEFORE_OPENED_STATE });
exports.onLeaveOpenedState = () => ({ type: exports.ON_LEAVE_OPENED_STATE });
//////////////////////////////////// FSM ////////////////////////////////////
function getStateNames(o) {
    let data = {};
    data.stateName = o + "State";
    data.beforeStateName = "onBefore" + _.upperFirst(data.stateName);
    data.leaveStateName = "onLeave" + _.upperFirst(data.stateName);
    data.stateNameCaps = _.snakeCase(data.stateName).toUpperCase();
    data.beforeStateNameCaps = _.snakeCase(data.beforeStateName).toUpperCase();
    data.leaveStateNameCaps = _.snakeCase(data.leaveStateName).toUpperCase();
    return data;
}
function getTransNames(o) {
    let data = {};
    data.transName = o + "Trans";
    data.beforeTransName = "onBefore" + _.upperFirst(data.transName);
    data.canTransName = "can" + _.upperFirst(data.transName);
    data.transNameCaps = _.snakeCase(data.transName).toUpperCase();
    data.beforeTransNameCaps = _.snakeCase(data.beforeTransName).toUpperCase();
    data.canTransNameCaps = _.snakeCase(data.canTransName).toUpperCase();
    return data;
}
exports.fsmOptions = {
    init: exports.CLOSED_STATE,
    transitions: [
        { name: exports.FIRE_DO_OPEN, from: exports.CLOSED_STATE, to: exports.OPENED_STATE, },
        { name: exports.FIRE_DO_CLOSE, from: exports.OPENED_STATE, to: exports.CLOSED_STATE, },
    ],
    methods: {
        onBeforeTransition: function (lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!exports.fsmDispatchFunctions.onBeforeTransition)
                return true;
            let event = "onBeforeTransition", type = trans.beforeTransNameCaps;
            return exports.fsmDispatchFunctions.onBeforeTransition({ event: event, type: type });
        },
        onTransition: function (lifecycle) {
            let trans = getTransNames(lifecycle.transition);
            if (!exports.fsmDispatchFunctions.onTransition)
                return true;
            let event = "onTransition", type = trans.transNameCaps;
            return exports.fsmDispatchFunctions.onTransition({ event: event, type: type });
        },
        onLeaveState: function (lifecycle) {
            let from_state = getStateNames(lifecycle.from);
            if (!exports.fsmDispatchFunctions.onLeaveState)
                return true;
            let event = "onLeaveState", type = from_state.leaveStateNameCaps;
            return exports.fsmDispatchFunctions.onLeaveState({ event: event, type: type });
        },
        onEnterState: function (lifecycle) {
            let to_state = getStateNames(lifecycle.to);
            if (!exports.fsmDispatchFunctions.onEnterState)
                return true;
            let event = "onEnterState", type = to_state.stateNameCaps;
            return exports.fsmDispatchFunctions.onEnterState({ event: event, type: type });
        }
    }
};
//////////////////////////////////// Sagas ////////////////////////////////////
exports.fsmTransitionSagas = [];
/* //////////////////////////////////// FSM Saga Generator //////////////////////////////////// */
function connectFsm(fdf) {
    return redux_saga_1.eventChannel(emit => {
        const onBeforeTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onTransition = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onLeaveState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        const onEnterState = state => {
            return new Promise((resolve, reject) => {
                debug(`event: ${state.event}, type: ${state.type}`);
                emit({ event: state.event, type: state.type, resolve: resolve, reject: reject });
            });
        };
        fdf.onBeforeTransition = onBeforeTransition;
        fdf.onTransition = onTransition;
        fdf.onLeaveState = onLeaveState;
        fdf.onEnterState = onEnterState;
        return () => {
            debug("Unsubscribe connectFsm");
            fdf.onBeforeTransition = null;
            fdf.onTransition = null;
            fdf.onLeaveState = null;
            fdf.onEnterState = null;
        };
    });
}
exports.connectFsm = connectFsm;
function* fsmDispatch(details) {
    yield effects_1.put({ type: details.type });
}
exports.fsmDispatch = fsmDispatch;
function* stateMachineDriver() {
    try {
        yield effects_1.put(exports.fsmCreate());
        const myClient = yield effects_1.call(connectFsm, exports.fsmDispatchFunctions);
        while (true) {
            let action = yield effects_1.take(myClient);
            let state = yield effects_1.select();
            if (action.event === "onEnterState" || action.event === "onTransition") {
                action.resolve();
                yield effects_1.fork(fsmDispatch, action);
            }
            else {
                try {
                    yield effects_1.put({ type: action.type });
                    action.resolve();
                }
                catch (err) {
                    debug(err);
                    action.reject();
                }
            }
        }
    }
    catch (err) {
        debug(err);
        //debugger;
    }
}
exports.stateMachineDriver = stateMachineDriver;
function* fireDoOpenSaga() {
    const fsm = yield effects_1.select(getFsmStateMachine);
    if (!fsm.can(exports.FIRE_DO_OPEN))
        throw new Error(`Cannot transition from ${fsm.state} with fireDoOpen`);
    debug('Dispatching fireDoOpen in FSM');
    fsm.fireDoOpen();
}
exports.fireDoOpenSaga = fireDoOpenSaga;
function* fireDoCloseSaga() {
    const fsm = yield effects_1.select(getFsmStateMachine);
    if (!fsm.can(exports.FIRE_DO_CLOSE))
        throw new Error(`Cannot transition from ${fsm.state} with fireDoClose`);
    debug('Dispatching fireDoClose in FSM');
    fsm.fireDoClose();
}
exports.fireDoCloseSaga = fireDoCloseSaga;
exports.fsmTransitionSagas.push(stateMachineDriver);
exports.fsmTransitionSagas.push(function* () {
    yield effects_1.takeLatest(exports.FIRE_DO_OPEN, fireDoOpenSaga);
    yield effects_1.takeLatest(exports.FIRE_DO_CLOSE, fireDoCloseSaga);
});
// ****************************** [ FSM Creation ] ****************************** //
exports.FSM_CREATE = "FSM_CREATE";
exports.fsmCreate = () => ({ type: exports.FSM_CREATE });
exports.fsmCreateReducer = (state = exports.initialStateMachineState, { type }) => {
    debug(type);
    switch (type) {
        case exports.FSM_CREATE: {
            let fsm = new StateMachine(exports.fsmOptions);
            debug("Creating FSM");
            let t = immutability_helper_1.default(state, { fsm: { $set: fsm } });
            return t;
        }
        default:
            return state;
    }
};
function getFsmState(state) {
    return state.app.fsm;
}
exports.getFsmState = getFsmState;
function getFsmStateMachine(state) {
    let fsmState = getFsmState(state);
    return fsmState.fsm.fsm;
}
exports.getFsmStateMachine = getFsmStateMachine;
//# sourceMappingURL=fsmDefinitions.js.map